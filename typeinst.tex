%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{amsmath,latexsym}
\usepackage[utf8x]{inputenc}
\usepackage[spanish]{babel}
\urldef{\mailsa}\path|{astradalucasezequiel@gmail.com|
\urldef{\mailsb}\path|marianvanetta@hotmail.com}
|    


\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Análisis de Herramienta, EasyCrypt}

% a short form should be given in case it is too long for the running head
%%\titlerunning{Analisis de Herramienta, EasyCrypt}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author
{
Astrada Lucas Ezequiel
\and
Vanetta Mariano
}
%
%%\authorrunning{Analisis de Herramienta, EasyCrypt}
% (feature abused for this document to repeat the title also on left hand pages) Aca sirve par el encabezado de pagina

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Universidad Nacional de Córdoba, Facultad de Matemática, Física, Astronomía y Computación\\
\mailsa\\
\mailsb\\
\url{https://www.famaf.unc.edu.ar/}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

%%\toctitle{Analisis de Herramienta, EasyCrypt}
\toctitle{EasyCrypt}
\maketitle


\begin{abstract}    
\href{https://www.easycrypt.info/trac/}{EasyCrypt} es un conjunto de herramientas para razonar sobre las propiedades reales de los cálculos probabilísticos con código contradictorio. Su aplicación principal es la construcción y verificación de pruebas criptográficas basadas en juegos. 
Es un marco formado por un lenguaje de programación junto a un motor de resolución de lógica de Hoare Relacional Probabilística. 
\keywords{Easycrypt  \and pruebas criptograficas \and juegos  \and Probabilistico.}
\end{abstract}

\section{Cosas que hacer}

\begin{itemize}
	\item Poner referencias (lucas) DONE
	\item Opinion: La intro es mas abstract que el abstract DONE
	\item Opinion: el cuadro de pwhile capaz que vaya en descrip
	\item no encuentro nada de estados, ni de abstraccion, ni que respuesta da en aspectos tecnicos
	\item Explicar seguridades de CMAC
	\item Aprendere cramer-shoup para el oral y terminar el caso de estudio seleccionado
	\item Hacer conclucion
	\item Revisar Ortografia DONE
\end{itemize}

\section{Introducción}
La criptografía desempeña un papel clave en la seguridad de la comunicación moderna e infractucturas informáticas.  Por este motivo es de suma importante diseñar sistemas criptgráficos que proporcionen grandes garantías de seguridad.
La sociedad depende hoy mas que nunca de la tecnologia, pero la inversión en seguridad es escasa y los riesgos de usar sistemas informaticos son cada dia mayores. La criptografia es una de las piedras angulares de la seguridad en este  ambito, por lo que recientemente se ha dedicado una cantidad considerable de recursos al desarrollo de herramientas que ayuden en la evaluacion y mejora de los algoritmos criptograficos. EasyCrypt es uno de estos sistemas. 

    A lo largo de este documento se discutirá sobre dicha herramienta, desde su historia hasta casos practicos que la utilizan.
    
\section{Contexto de creacion de la herramienta}
El desarrollo de EasyCrypt se inició en 2009, y el prototipo inicial se usó para probar la seguridad de varias construcciones, incluso el esquema de cifrado Cramer-Shoup(*), el diseño de la función de hash iterativa Merfle-Damgaard(**) y el esquema de cifrado ZEAP(***). EasyCrypt ha sido desarrollado inicialmente por el Instituto de Software IMDEA e Inria. Actualmente se desarrolla en el instituto IMDEA Software, Inria y École Polytechnique. EasyCrypt es un proyecto de software libre, distribuido bajo los términos de la licencia CeCILL-B, y su código fuente está accesible desde la página del proyecto. 
La versión actual de EasyCrypt (versión 1.0) aún está en desarrollo. 

\section{Objetivo de la herramienta} 

Esta herramienta apunta a solucionar problemas de seguridad. EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. Esta es una herramienta que se utiliza en las etapas de desarrollo y testing de software. 

EasyCrypt funciona como un intérprete de un lenguaje de propósito general y de forma interactiva: cuando se le proporciona un fichero o fuente a evaluar, lo recorre de arriba hacia abajo comprobando que todos los pasos de las demostraciones son correctos. Usando Proof General, un modo de editor de texto Emacs, es posible editar un fichero fuente mientras el intérprete lo va emulando sobre la marcha, ayudando y guiando al usuario a medida que éste desarrolla cada demostración. 

\section{Descripción de la herramienta del lado del usuario}

EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. 

\begin{itemize}
	\item Lenguaje de especificación.
	\item Lenguaje de expresiones.
	\item Lenguaje de expresiones probabilísticas.
	\item Lenguaje pWhile.
	\item Lenguajes de demostración.
	\item Juicios.
	\item Tácticas.
\end{itemize}

EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. 

\section{Aspectos tecnicos}
EasyCrypt trabaja con enfoque basado en juego, cuyos principales actores son los ADVERSARIOS y los ORACULOS. Este contiene variables globales y una coleciones de procesos: Procesos definidos (Oráculos) y Procesos Abstractos (Adversarsios).

Éste posee 4 bases:
Lenguaje Programacional:
El lenguaje utilizado es pWhile el cual es de tipado fuerte, imperativo probabilistico:

\begin{Verbatim}
C ::= skip		 	nop
	|V <- E		    deterministic assignment
	|V <- DE		   probabilistic assignment
	|if E then C else C	conditional
	|while E do C	      loop
	|V <- P(E, . . . , E)      procedure call
	|C; C		      sequence
Donde V = {variables identificadora}, P = {nombres de procesos},
 E = {expresiones de prueba}
\end{Verbatim}

Semántica Denotacional:
Estos programas son interpretados como funciones, que se mapean en la memoria.

Logica Relacional: Se utiliza el método probabilístico RELATIONAL HOARE LOGIC (pRHL):
		
\centerline{$\models$ c1 $\sim$ c2 : $\Psi$ $\implies$ $\Phi$}	
			
donde c1,c2 son programas probabilísticos y los símbolos corresponden a la pre y post condición.

Dentro de EasyCrypt la gramática es la siguiente:

\centerline{$\Psi$, $\Phi$ ::= e $\mid$ $\neg$ $\Phi$ $\mid$ $\Psi$ ∧ $\Phi$ $\mid$ $\Psi$ ∨ $\Phi$ $\mid$ $\Psi$ $\implies$ $\Phi$ $\mid$ $\forall$ x. $\Phi$ $\mid$ $\exists$ x. $\Phi$}

donde la e corresponde a una expresión Booleana.


Razonamiento probabilístico:
Estos razonamientos se expresan en términos de eventos probabilísticos y no como juicios de pRHL.\cite{article5}


Easycrypt utiliza sistemas de reducción abstractos sobre todo con el cálculo lambda, estos son:

\begin{itemize}

	\item Call-by-name: reduce la expresión de más afuera de la izquierda salvo que este en forma normal débil. No es estricta.

	\item Call-by-value: reduce la expresión de más adentro de la izquierda, salvo que este en forma normal débil. Es estricta.

	\item Applicative order: reduce la expresión de más adentro a la izquierda, salvo que este de forma normal. Es estricta.
\end{itemize}

tipo de respuestas: proof sketches con formato COQ, para ser luego ser ejecutadas en dicho formato.\cite{article6}


\section{COMPARACIÓN DE PROGRAMAS}
\centerline{\emph{CertiCrypt}}

En la parte programacional, EasyCrypt no posee bucles ni procesos recursivos, CertiCrypt si. En el caso de las evidencias generadas, EasyCrypt es parcial por no tener generadores de pruebas COQ (se esta buscando agregar esta feature). Este también genera pruebas en base a la probabilidad y no máquinas totalmente probadas.

\begin{table}
  \caption{Comparación de EasyCrypt con CertiCrypt}
  \label{tab:simple1}
  \centering
  \begin{tabular}{ |p{3.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 & \multicolumn{2}{|c|}{CertiCrypt} & \multicolumn{2}{|c|}{EasyCrypt} & \multicolumn{2}{|c|}{Extracted} \\\cline{2-7}

 &Lines&Time&Lines&Time&Lines&Time\\\cline{2-7}
 \hline
 ElGamal(IND-CPA) & 565 & 45s & 190 & 12s & 1130 & 23s\\
 Hashed ElGamal(IND-CPA) & 1255  & 1m 5s & 243  & 33s & 1772 & 41s\\
 Full-Domain Hash(EF-CMA) & 2035 & 5m 46s&  509 & 1m 26s & 2724 & 1m11s\\
 Cramer-Shoup(IND-CCA) & n/a & n/a & 1637 & 5m 12s & 5504 & 3m14s\\
 \hline
\end{tabular}
\end{table}

Hardware para esta prueba: 2.8GHz Intel Core 2 Duo processor con 4GB de RAM en Mac OS X 10.6.7.\cite{article5}

Con el gráfico anterior podemos concluir que la mayor diferencia entre estos dos programas es la rapidez y facilidad en la construcción de pruebas.

\centerline{\emph{CRYPTHOL}}

En la semántica, EasyCrypt soporta distribuciones de probabildad discretas, todas expresadas usando el lenguaje pWhile. Crypthol tiene el mismo dominio y el lenguaje es igual de expresivo gracias al operador de punto fijo. A diferencia del lenguaje imperativo usado por EasyCrypt, CryptHol utiliza lenguaje funcional embebido.

CryptHol crea su dominio semántico atraves de los principios de HOL y tiene la un asistente de prueba (COQ o Isabelle) para corroborar las derivaciones de las reglas de prueba. En cambio easycrypt no posee ningún asistente para las pruebas, entonces hay que confiar que las implementaciones en ocaml y que los "solucionadores" externos SMT son correctas.

Otra diferencia importante radica en las "librerías" disponibles. Como ya mencionamos, EasyCrypt no posee asistentes de pruebas, por lo tanto tiene librerias muy chicas que le permite razonar programas rápidamente, a diferencia de CryptHol que al estar enfocado en resolver matemática pura, necesita de librerías completas que son brindadas por Isabelle/HOL o COQ.

In EasyCrypt and CryptHOL, the efficiency of computations
cannot be expressed formally because their logics identify terms up to computation:
for example, the computation ($\lambda$x. x+x)(1) cannot be distinguished from the value 2
En ambos programas la eficiencia de computos no puede ser expresada formalmente porque sus locas identifican términos hasta computos, por ejemplo, ($\lambda$x. x+x) no puede ser distinguido de el valor 2.\cite{article8}

\begin{table}
  \caption{Comparación de EasyCrypt con CryptHOL}
  \label{tab:simple2}
  \centering
  \begin{tabular}{ |p{4cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 Cryptographic Algorithm & Security property & CryptHOL & EasyCrypt\\\cline{1-4}
 \hline
 RP-RF switching lemma &  & 120 & 448\\
 Elgamal & IND-CPA & 49  & 68\\
 Hashed Elgamal in the ROM & IND-CPA & 253 &  216\\
 \hline
\end{tabular}
\end{table}


No se encontró el hardware utilizado para esta prueba.




\section{Casos de estudios}
EasyCrypt es una herramienta muy potente para probar problemas de seguridad, por lo tanto los siguientes casos de estudio hace referencia mayoritariamente la criptografía.

\centerline{\emph{IND-CPA}}

Hashed ElGamal es una variante de encriptacion ElGamal, la cual puede ser reducida a lo siguiente (Computational Diffie-Hellman) : Es difícil computar $g^{x*y}$ dado $g^x$ y $g^y$ donde x e y son eventos aleatorios uniformes dentro de Zq.
Para esta prueba primero es necesario expresar los cinco ingredientes para el input de EasyCrypt:
\begin{itemize}
	\item Tipo, constantes y declaracioenes del operador.
	\item Axiomas.
	\item Defiiciones del "Juego".
	\item Juicios en pRHL.
	\item Claims de la probabildad.
\end{itemize}

Resultado: La reducción de código es sustancial tanto que es 5 veces más chica que la inicial asi también como el desempeno de EasyCrypt (medido en tiempo) fue de 33 segundos.\cite{article5}


\centerline{\emph{CMAC}}
\cite{article7}
CMAC fue propuesto por Iwata y Kurosawa con el nombre de OMAC1, el cual cuenta co una prueba criptografica basada en juegos muy compleja. Luego se fue transformando hasta llegar al CBC-MAC (bloque cifrado en cadena-codigo de autentificacion del mensaje, cipher block chaining-message authentication code). En este, el mensaje es dividido en lista de bloques. Cada bloque es enmascado usando el resultado del cifrado de bloque anterior, con esta dependencia se asegura que si se cambia un bit  del mensaje, el resto cambiara inpredeciblemente.

Los MAC cuentan con con 3 algoritmos (generador de clave, tageo y de verificación). Estos deben cumplir con 4 características, deben ser correctos, seguros y determinísticos. A diferencia de los BCB que solo requieren ser seguros. (explicamos aca ?)
C-MAC se extiende en:
\begin{itemize}
	\item CBC-MAC
	\item ECBC
	\item FCBC
	\item XCBC
\end{itemize}
 explicar

Para realizar esta prueba se necesita probar que:
\begin{itemize}
	\item ECBC es una MAC segura
	\item FCBC es perfectamente indistinguible de ECBC
	\item XCBC es computacionalmente indistinguible FCBC
	\item CMAC es computacionalmente indistinguible de FCBC	
\end{itemize}
El caso fue exitoso ya que probó que CMAC es computacionalmente es indistinguible de FCBC, asi también los lemas utilizado para la prueba.


\centerline{\emph{Cramer-Shoup Cryptosystem}}

Este caso se hizo famoso ya que fue el primer encriptador asimétrico eficiente. La idea es probar que es seguro contra ataques "adaptive chosen-ciphertext"
Mediante la prueba de las definiciones de Target Collision-Resistance y CCA-advantange), se puede probar el teorema de "Security of Cramer-Shoup".
La prueba fue exitosa para cualquier "decryption query" (bajo la condicion de u =! u')\cite{article5}


\section{Conclusión}

A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

\section{References}

\begin{thebibliography}{1}
\bibitem{article2}
EasyCrypt: A Tutorial, 
Gilles Barthe
François Dupressoir,Benjamin Grégoire,César Kunz, 
Benedikt Schmidt ,and Pierre-Yves Strub.
\bibitem{article3}
EasyCrypt Reference Manual.
\bibitem{article4}
Guillermo Ramos Gutiérrez: Desarrollo de  funcionalidad para un marco orientado sobre algoritmos criptográficos.
\bibitem{article5}
%%lucas added references
Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, Santiago Zanella Béguelin: Computer-Aided Security Proofs
for the Working Cryptographer.
\bibitem{article6}
Guillermo Ramos Gutiérrez: Implementing a term rewriting
engine for the EasyCrypt framework.
\bibitem{article7}
Cécile Baritel-Ruet, François Dupressoir, Pierre-Alain Fouque, Benjamin Grégoire. Formal Security.
Proof of CMAC and Its Variants. CSF 2018 - 31st EEE Computer Security Foundations Symposium,
Jul 2018, Oxford, United Kingdom.
\bibitem{article8}
David A. Basin, Andreas Lochbihler, and S. Reza Sefidgar: CryptHOL: Game-based Proofs in
Higher-order Logic.
\bibitem{article9}
Descarga e instalación https://github.com/EasyCrypt/easycrypt. 
\end{thebibliography}
\end{document}
