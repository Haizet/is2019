
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{amsmath,latexsym}
\usepackage[utf8x]{inputenc}
\usepackage[spanish]{babel}
\urldef{\mailsa}\path|{astradalucasezequiel@gmail.com|
\urldef{\mailsb}\path|marianvanetta@hotmail.com}
|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Analisis de Herramienta, EasyCrypt}

% a short form should be given in case it is too long for the running head
\titlerunning{Analisis de Herramienta, EasyCrypt}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Astrada Lucas Ezequiel
\and Vanetta Mariano}
%
\authorrunning{Analisis de Herramienta, EasyCrypt}
% (feature abused for this document to repeat the title also on left hand pages) Aca sirve par el encabezado de pagina

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Universidad Nacional de Cordoba, Facultad de Matematica, Fisica, Astronomia y Computacion\\
\mailsa\\
\mailsb\\
\url{https://www.famaf.unc.edu.ar/}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Analisis de Herramienta, EasyCrypt}
\maketitle


\begin{abstract}

\end{abstract}

\section{Introduccion}

\section{Contexto de creacion de la herramienta}

EasyCrypt es un conjunto de herramientas para razonar sobre las propiedades reales de los cálculos probabilísticos con código contradictorio. Su aplicación principal es la construcción y verificación de pruebas criptográficas basadas en juegos. 
Es un marco formado por un lenguaje de programación junto a un motor de resolución de lógica de Hoare Relacional Probabilística. El desarrollo de EasyCrypt se inició en 2009, y el prototipo inicial se usó para probar la seguridad de varias construcciones, incluso el esquema de cifrado Cramer-Shoup(*), el diseño de la función de hash iterativa Merfle-Damgaard(**) y el esquema de cifrado ZEAP(***). EasyCrypt ha sido desarrollado inicialmente por el Instituto de Software IMDEA e Inria. Actualmente se desarrolla en el instituto IMDEA Software, Inria y École Polytechnique. EasyCrypt es un proyecto de software libre, distribuido bajo los términos de la licencia CeCILL-B, y su código fuente está accesible desde la página del proyecto. 
La versión actual de EasyCrypt (versión 1.0) aún está en desarrollo. 

\section{Objetivo de la herramienta} 

Esta herramienta apunta a solucionar problemas de seguridad. EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. Esta es una herramienta que se utiliza en las etapas de desarrollo y testing de software. 

EasyCrypt funciona como un intérprete de un lenguaje de propósito general y de forma interactiva: cuando se le proporciona un fichero o fuente a evaluar, lo recorre de arriba hacia abajo comprobando que todos los pasos de las demostraciones son correctos. Usando Proof General, un modo de editor de texto Emacs, es posible editar un fichero fuente mientras el intérprete lo va emulando sobre la marcha, ayudando y guiando al usuario a medida que éste desarrolla cada demostración. 

\section{Descripción de la herramienta del lado del usuario}

EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. 

\begin{itemize}
	\item Lenguaje de especificación
	\item Lenguaje de expresiones
	\item Lenguaje de expresiones probabilísticas
	\item Lenguaje pWhile
	\item Lenguajes de demostración
	\item Juicios
	\item Tácticas
\end{itemize}

\section{Aspectos tecnicos}
EasyCrypt trabaja con enfoque basado en juego, cuyos principales actores son los ADVERSARIOS y los ORACULOS. Este contiene variables globales y una coleciones de procesos: Procesos definidos (Oraculos) y Procesos Abstractos (Adversarsios).

Este posee 4 bases:
Lenguaje Programacional:
El lenguaje utilizado es pWhile el cual es de tipado fuerte, imperativo probabilistico.:

\begin{Verbatim}
C ::= skip		 	nop
	|V <- E		    deterministic assignment
	|V <- DE		   probabilistic assignment
	|if E then C else C	conditional
	|while E do C	      loop
	|V <- P(E, . . . , E)      procedure call
	|C; C		      sequence
Donde V = {variables identificadora}, P = {nombres de procesos},
 E = {expresiones de prueba}
\end{Verbatim}

Semantica Denotacional:
Estos programas son interpretados como funciones, que se mapean en la memoria.

Logica Relacional: Se utiliza el metodo probabilistico RELATIONAL HOARE LOGIC (pRHL):
		
\centerline{$\models$ c1 $\sim$ c2 : $\Psi$ $\implies$ $\Phi$}	
			
donde c1,c2 son programas probabilisticos y los simbolos corresponden a la pre y post condicion.

Dentro de EasyCrypt la gramatica es la siguiente:

\centerline{$\Psi$, $\Phi$ ::= e $\mid$ $\neg$ $\Phi$ $\mid$ $\Psi$ ∧ $\Phi$ $\mid$ $\Psi$ ∨ $\Phi$ $\mid$ $\Psi$ $\implies$ $\Phi$ $\mid$ $\forall$ x. $\Phi$ $\mid$ $\exists$ x. $\Phi$}

donde la e corresponde a una expresion Booleana.


Razonamiento probabilistico:
Estos razonamientos se expresan en terminos de eventos probabilisticos y no como juicios de pRHL.\cite{article5}


Easycrypt utiliza sistemas de reduccion abstractos sobre todo con el calculo lambda, estos son:

	-Call-by-name: reduce la exprecion de mas afuera de la izquierda salvo que este en forma normal devil. No es estricta.

	-Call-by-value: reduce la expresion de mas adentro de la izquierda, salvo que este en forma normal devil. Es estricta.

	-Applicative order: reduce la expresion de mas adentro a la izquierda, salvo que este de forma noraml. Es estricta.\cite{article6}


------------------------------
-no encuentro nada de estados, ni de abstraccion

-tipo de respuestas


\section{COMPARACION DE PROGRAMAS}
\centerline{\emph{CertyCrypt}}

En la parte programacional, EasyCrypt no posee bucles ni procesos recursivos. En el caso de las evidencias generadas, EasyCrypt es parcial por no tener generadores de pruebas COQ (se esta buscando agregar esta feature). Este tambien genera pruebas en base a la probabilidad y no maquinas totalmente probadas.

\begin{table}
  \caption{Comparación de EasyCrypt con CertyCrypt}
  \label{tab:simple1}
  \centering
  \begin{tabular}{ |p{3.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 & \multicolumn{2}{|c|}{CertiCrypt} & \multicolumn{2}{|c|}{EasyCrypt} & \multicolumn{2}{|c|}{Extracted} \\\cline{2-7}

 &Lines&Time&Lines&Time&Lines&Time\\\cline{2-7}
 \hline
 ElGamal(IND-CPA) & 565 & 45s & 190 & 12s & 1130 & 23s\\
 Hashed ElGamal(IND-CPA) & 1255  & 1m 5s & 243  & 33s & 1772 & 41s\\
 Full-Domain Hash(EF-CMA) & 2035 & 5m 46s&  509 & 1m 26s & 2724 & 1m11s\\
 Cramer-Shoup(IND-CCA) & n/a & n/a & 1637 & 5m 12s & 5504 & 3m14s\\
 \hline
\end{tabular}
\end{table}

Hardware para esta prueba: 2.8GHz Intel Core 2 Duo processor con 4GB de RAM en Mac OS X 10.6.7.\cite{article5}



\centerline{\emph{CRYPTHOL}}

En la semantica, EasyCrypt soporta distribuciones de probabildad discretas, todas expresadas usando el lenguaje pWhile. Crypthol tiene el mismo dominio y el lenguaje es igual de expresivo gracias al operador de punto fijo.

CryptHol crea su dominio semantico atravez de los principios de HOL y tiene la un asistente de prueba (COQ o Isabelle) para corroborar las derivaciones de las reglas de prueba. En cambio easycrypt no posee ningun asistente para las pruebas, entonces hay que confiar que las implementaciones en ocaml y que los "resolvedores" externos SMT son correctas.\cite{article8}


\begin{table}
  \caption{Comparación de EasyCrypt con CryptHOL}
  \label{tab:simple2}
  \centering
  \begin{tabular}{ |p{4cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 Cryptographic Algorithm & Security property & CryptHOL & EasyCrypt\\\cline{1-4}
 \hline
 RP-RF switching lemma &  & 120 & 448\\
 Elgamal & IND-CPA & 49  & 68\\
 Hashed Elgamal in the ROM & IND-CPA & 253 &  216\\
 \hline
\end{tabular}
\end{table}


NO se encontro el hardware utilizado para esta prueba




\section{Casos de estudios}
EasyCrypt es una herramienta muy potente para probar problemas de seguridad, por lo tanto los siguientes casos de estudio hace referencia mayoritariamente la criptografia.

\centerline{\emph{IND-CPA}}

Hashed ElGamal es una variante de encriptacion ElGamal, la cual puede ser reducida a lo siguiente (Computational Diffie-Hellman) : Es dificil computar $g^{x*y}$ dado $g^x$ y $g^y$ donde x e y son eventos aleatorios uniformes dentro de Zq.
Para esta prueba primero es necesario expresar los cinco ingredientes para el input de EasyCrypt:
-Tipo, constantes y declaracioenes del operador;

-Axiomas;

-Defiiciones del "Juego"

-Juicios en pRHL;

-"Claims" de la probabildad

EXPLICAMOS O NO:

Resultado: La reduccion de codigo es sustancial tanto que es 5 veces mas chica que la inicial.\cite{article5}



\centerline{\emph{Cramer-Shoup Cryptosystem}}

Este caso se hizo famoso ya que fue el primer encriptador asimetrico eficiente. La idea es probar que es seguro contra ataques "adaptive chosen-ciphertext"
Mediante la prueba de las definiciones de "Target Collision-Resistance" y CCA-advantange), se puede probar el teorema de "Security of Cramer-Shoup".
La prueba fue exitosa para cualquier "decryption query" (bajo la condicion de u =! u')\cite{article5}



\centerline{\emph{CMAC 6A caso exitoso}}
\cite{article7}
s
CMAC fue propuesto por 
The CMAC standard, when initially proposed by
Iwata and Kurosawa as OMAC1, was equipped with a complex
game-based security proof. Following recent advances in formal
verification for game-based security proofs, we formalize a proof
of unforgeability for CMAC in EasyCrypt. A side effect of
this proof includes improvements and extensions to EasyCrypt’s
standard libraries. This formal proof obtains security bounds
very similar to Iwata and Kurosawa’s for CMAC, but also
proves secure a certain number of intermediate constructions of
independent interest, including ECBC, FCBC and XCBC. This
work represents one more step in the direction of obtaining a
reliable set of independently verifiable evidence for the security
of international cryptographic standards.



\section{Conclusion}

A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

\section{References}

\begin{thebibliography}{4}
\bibitem{article5}
Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, Santiago Zanella Béguelin: Computer-Aided Security Proofs
for the Working Cryptographer
\bibitem{article6}
Guillermo Ramos Gutiérrez: Implementing a term rewriting
engine for the EasyCrypt framework
\bibitem{article7}
Cécile Baritel-Ruet, François Dupressoir, Pierre-Alain Fouque, Benjamin Grégoire. Formal Security
Proof of CMAC and Its Variants. CSF 2018 - 31st EEE Computer Security Foundations Symposium,
Jul 2018, Oxford, United Kingdom.
\bibitem{article8}
David A. Basin, Andreas Lochbihler, and S. Reza Sefidgar: CryptHOL: Game-based Proofs in
Higher-order Logic

\end{thebibliography}
\end{document}
