%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{url}
\usepackage{fancyvrb}
\usepackage{hyperref}
\usepackage{amsmath,latexsym}
\usepackage[utf8x]{inputenc}
\usepackage[spanish]{babel}
\urldef{\mailsa}\path|{astradalucasezequiel@gmail.com|
\urldef{\mailsb}\path|marianvanetta@hotmail.com}
|    


\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Análisis de Herramienta, EasyCrypt}

% a short form should be given in case it is too long for the running head
%%\titlerunning{Analisis de Herramienta, EasyCrypt}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author
{
Astrada Lucas Ezequiel
\and
Vanetta Mariano
}
%
%%\authorrunning{Analisis de Herramienta, EasyCrypt}
% (feature abused for this document to repeat the title also on left hand pages) Aca sirve par el encabezado de pagina

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Universidad Nacional de Córdoba, Facultad de Matemática, Física, Astronomía y Computación\\
\mailsa\\
\mailsb\\
\url{https://www.famaf.unc.edu.ar/}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

%%\toctitle{Analisis de Herramienta, EasyCrypt}
\toctitle{EasyCrypt}
\maketitle


\begin{abstract}    
EasyCrypt es un conjunto de herramientas para razonar sobre las propiedades reales de los cálculos probabilísticos con código contradictorio. Su aplicación principal es la construcción y verificación de pruebas criptográficas basadas en juegos. 
Es un marco formado por un lenguaje de programación junto a un motor de resolución de lógica de Hoare Relacional Probabilística. A lo largo de este documento se discutirá sobre dicha herramienta, desde su historia hasta casos practicos que la utilizan.
\cite{article1}


\keywords{Easycrypt  \and Pruebas criptograficas \and Juegos  \and Probabilistico.}
\end{abstract}


\section{Introducción}
La criptografía desempeña un papel clave en la seguridad de la comunicación moderna e infractucturas informáticas.  Por este motivo es de suma importante diseñar sistemas criptgráficos que proporcionen grandes garantías de seguridad.
La sociedad depende hoy mas que nunca de la tecnologia, pero la inversión en seguridad es escasa y los riesgos de usar sistemas informaticos son cada dia mayores. La criptografia es una de las piedras angulares de la seguridad en este  ambito, por lo que recientemente se ha dedicado una cantidad considerable de recursos al desarrollo de herramientas que ayuden en la evaluacion y mejora de los algoritmos criptograficos. EasyCrypt es uno de estos sistemas.

EasyCrypt busca facilitar en tiempo y en simplificar pruebas de seguridad de altisima complejidad.En la seccion 2 y 3 introduce el contexto de creacion del programa. Seccion 4 analizara la usabilidad que brinda Easycrypt al usuario. Las especificaciones tecnicas, comparaciones con otros programas y casos de uso se encontraran en las secciones 5, 6 y 7. Por ultimo enunciaremos nuestra conclusion y opiniones sobre EasyCrypt.
    
\section{Contexto de creacion de la herramienta}
El desarrollo de EasyCrypt se inició en 2009, y el prototipo inicial se usó para probar la seguridad de varias construcciones, incluso el esquema de cifrado Cramer-Shoup, el diseño de la función de hash iterativa Merfle-Damgaard y el esquema de cifrado ZEAP. EasyCrypt ha sido desarrollado inicialmente por el Instituto de Software \href{http://www.imdea.org/es}{IMDEA} (Institutos Madrileños de Estudios Avanzados) e \href{https://www.inria.fr/en/}{Inria} (Instituto de investigacion para ciencias digitales). Actualmente se desarrolla en el instituto IMDEA Software, Inria y \href{https://www.polytechnique.edu/}{École Polytechnique} (Instituto publico frances de educacion avanzada e investigacion). EasyCrypt es un proyecto de software libre, distribuido bajo los términos de la licencia CeCILL-B, y su código fuente está accesible desde la página del proyecto. 
La versión actual de EasyCrypt (versión 1.0), lanzada el 10 Octubre 2017, aún está en desarrollo. 
\cite{article2}

\section{Objetivo de la herramienta} 

Esta herramienta apunta a solucionar problemas de seguridad. EasyCrypt usa varios lenguajes de programación distintos a la hora de evaluar un código fuente. Esta es una herramienta que se utiliza en las etapas de desarrollo y testing de software. 

EasyCrypt funciona como un intérprete de un lenguaje de propósito general y de forma interactiva: cuando se le proporciona un fichero o fuente a evaluar, lo recorre de arriba hacia abajo comprobando que todos los pasos de las demostraciones son correctos. Usando Proof General, un modo de editor de texto Emacs, es posible editar un fichero fuente mientras el intérprete lo va emulando sobre la marcha, ayudando y guiando al usuario a medida que éste desarrolla cada demostración. 

\section{Descripción de la herramienta del lado del usuario}

Easycrypt tiene su propio programa  para ser utilizado el cual puede ser bajado de github.\cite{link1}
Easycrypt se utiliza en la terminal de comando y tiene un funcionamiento muy simple pero poco intuitivo; Se ingresa el codigo deseado y al ejecutarlo este analiza linea por linea hasta llegar a un resultado o error. Por eso es mas viable utilizar EMACS.\cite{link2}. Emacs es un editor de texto que tiene un interprete de Turing Completa el cual usa el lenguaje ELisp. Puede ser instalado en las 3 sistemas operativos mas utilizados: Windows, Mac OS, y distribuciones de Linux. Utiliza archivos *.ec  .Es un programa en el cual la visualizacion de los elementos es mas amigable con el usuario. Tiene por un lado el archivo selecionado y por otro las ejecuciones realizadas. La interfaz permite analizar el archivo paso por paso(next) o ejectutarlo completamente(use), volver pasos atras(undo), revisar cual es el estado en determinada linea(state), entre otras opciones.


\section{Aspectos tecnicos}
EasyCrypt trabaja con enfoque basado en juego, cuyos principales actores son los ADVERSARIOS y los ORACULOS. Este contiene variables globales y una coleciones de procesos: Procesos definidos (Oráculos) y Procesos Abstractos (Adversarsios).

Éste posee 4 bases:
Lenguaje Programacional:
El lenguaje utilizado es pWhile el cual es de tipado fuerte, imperativo probabilistico:

\begin{Verbatim}
C ::= skip		 	nop
	|V <- E		    deterministic assignment
	|V <- DE		   probabilistic assignment
	|if E then C else C	conditional
	|while E do C	      loop
	|V <- P(E, . . . , E)      procedure call
	|C; C		      sequence
Donde V = {variables identificadora}, P = {nombres de procesos},
 E = {expresiones de prueba}
\end{Verbatim}

Semántica Denotacional:
Estos programas son interpretados como funciones, que se mapean en la memoria.

Logica Relacional: Se utiliza el método probabilístico RELATIONAL HOARE LOGIC (pRHL):
		
\centerline{$\models$ c1 $\sim$ c2 : $\Psi$ $\implies$ $\Phi$}	
			
donde c1,c2 son programas probabilísticos y los símbolos corresponden a la pre y post condición.

Dentro de EasyCrypt la gramática es la siguiente:

\centerline{$\Psi$, $\Phi$ ::= e $\mid$ $\neg$ $\Phi$ $\mid$ $\Psi$ ∧ $\Phi$ $\mid$ $\Psi$ ∨ $\Phi$ $\mid$ $\Psi$ $\implies$ $\Phi$ $\mid$ $\forall$ x. $\Phi$ $\mid$ $\exists$ x. $\Phi$}

donde la e corresponde a una expresión Booleana.


Razonamiento probabilístico:
Estos razonamientos se expresan en términos de eventos probabilísticos y no como juicios de pRHL.\cite{article3}


Easycrypt utiliza sistemas de reducción abstractos sobre todo con el cálculo lambda, estos son:

\begin{itemize}

	\item Call-by-name: reduce la expresión de más afuera de la izquierda salvo que este en forma normal débil. No es estricta.

	\item Call-by-value: reduce la expresión de más adentro de la izquierda, salvo que este en forma normal débil. Es estricta.

	\item Applicative order: reduce la expresión de más adentro a la izquierda, salvo que este de forma normal. Es estricta.
\end{itemize}

tipo de respuestas: proof sketches con formato COQ, para ser luego ser ejecutadas en dicho formato.\cite{article4}


\section{COMPARACIÓN DE PROGRAMAS}
\centerline{\emph{CertiCrypt}}

En la parte programacional, EasyCrypt no posee bucles ni procesos recursivos, CertiCrypt si. En el caso de las evidencias generadas, EasyCrypt es parcial por no tener generadores de pruebas COQ (se esta buscando agregar esta feature). Este también genera pruebas en base a la probabilidad y no máquinas totalmente probadas.

\begin{table}
  \caption{Comparación de EasyCrypt con CertiCrypt}
  \label{tab:simple1}
  \centering
  \begin{tabular}{ |p{3.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 & \multicolumn{2}{|c|}{CertiCrypt} & \multicolumn{2}{|c|}{EasyCrypt} & \multicolumn{2}{|c|}{Extracted} \\\cline{2-7}

 &Lines&Time&Lines&Time&Lines&Time\\\cline{2-7}
 \hline
 ElGamal(IND-CPA) & 565 & 45s & 190 & 12s & 1130 & 23s\\
 Hashed ElGamal(IND-CPA) & 1255  & 1m 5s & 243  & 33s & 1772 & 41s\\
 Full-Domain Hash(EF-CMA) & 2035 & 5m 46s&  509 & 1m 26s & 2724 & 1m11s\\
 Cramer-Shoup(IND-CCA) & n/a & n/a & 1637 & 5m 12s & 5504 & 3m14s\\
 \hline
\end{tabular}
\end{table}

Hardware para esta prueba: 2.8GHz Intel Core 2 Duo processor con 4GB de RAM en Mac OS X 10.6.7.\cite{article3}

Con el gráfico anterior podemos concluir que la mayor diferencia entre estos dos programas es la rapidez y facilidad en la construcción de pruebas.

\centerline{\emph{CRYPTHOL}}

En la semántica, EasyCrypt soporta distribuciones de probabildad discretas, todas expresadas usando el lenguaje pWhile. Crypthol tiene el mismo dominio y el lenguaje es igual de expresivo gracias al operador de punto fijo. A diferencia del lenguaje imperativo usado por EasyCrypt, CryptHol utiliza lenguaje funcional embebido.

CryptHol crea su dominio semántico atraves de los principios de HOL y tiene la un asistente de prueba (COQ o Isabelle) para corroborar las derivaciones de las reglas de prueba. En cambio easycrypt no posee ningún asistente para las pruebas, entonces hay que confiar que las implementaciones en ocaml y que los "solucionadores" externos SMT son correctas.

Otra diferencia importante radica en las "librerías" disponibles. Como ya mencionamos, EasyCrypt no posee asistentes de pruebas, por lo tanto tiene librerias muy chicas que le permite razonar programas rápidamente, a diferencia de CryptHol que al estar enfocado en resolver matemática pura, necesita de librerías completas que son brindadas por Isabelle/HOL o COQ.

En ambos programas la eficiencia de computos no puede ser expresada formalmente porque sus locas identifican términos hasta computos, por ejemplo, ($\lambda$x. x+x) no puede ser distinguido de el valor 2.\cite{article6}

\begin{table}
  \caption{Comparación de EasyCrypt con CryptHOL}
  \label{tab:simple2}
  \centering
  \begin{tabular}{ |p{4cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 Cryptographic Algorithm & Security property & CryptHOL & EasyCrypt\\\cline{1-4}
 \hline
 RP-RF switching lemma &  & 120 & 448\\
 Elgamal & IND-CPA & 49  & 68\\
 Hashed Elgamal in the ROM & IND-CPA & 253 &  216\\
 \hline
\end{tabular}
\end{table}


No se encontró el hardware utilizado para esta prueba.




\section{Casos de estudios}
EasyCrypt es una herramienta muy potente para probar problemas de seguridad, por lo tanto los siguientes casos de estudio hace referencia mayoritariamente la criptografía.

\centerline{\emph{IND-CPA}}

Hashed ElGamal es una variante de encriptacion ElGamal, la cual puede ser reducida a lo siguiente (Computational Diffie-Hellman) : Es difícil computar $g^{x*y}$ dado $g^x$ y $g^y$ donde x e y son eventos aleatorios uniformes dentro de $\mathbb{Z}_q$.
Para esta prueba primero es necesario expresar los cinco ingredientes para el input de EasyCrypt:
\begin{itemize}
	\item Tipo, constantes y declaracioenes del operador.
	\item Axiomas.
	\item Defiiciones del "Juego".
	\item Juicios en pRHL.
	\item Claims de la probabildad.
\end{itemize}

Resultado: La reducción de código es sustancial tanto que es 5 veces más chica que la inicial asi también como el desempeno de EasyCrypt (medido en tiempo) fue de 33 segundos.\cite{article3}



\centerline{\emph{CMAC}}
\cite{article5}
CMAC fue propuesto por Iwata y Kurosawa con el nombre de OMAC1, el cual cuenta co una prueba criptografica basada en juegos muy compleja. Luego se fue transformando hasta llegar al CBC-MAC (bloque cifrado en cadena-codigo de autentificacion del mensaje, cipher block chaining-message authentication code). En este, el mensaje es dividido en lista de bloques. Cada bloque es enmascado usando el resultado del cifrado de bloque anterior, con esta dependencia se asegura que si se cambia un bit  del mensaje, el resto cambiara inpredeciblemente.

Los MAC cuentan con con 3 algoritmos (generador de clave, tageo y de verificación). Estos deben cumplir con las siguientes características: deben ser correctos, seguros y determinísticos. A diferencia de los BCB que solo requieren ser seguros. (explicamos aca ?)

Para realizar esta prueba se necesita probar que:

\centerline{\emph{ECBC es una MAC segura}}
\centerline{$\land$}
\centerline{\emph{FCBC es perfectamente indistinguible de ECBC}}
\centerline{$\land$}
\centerline{\emph{XCBC es computacionalmente indistinguible FCBC}}
\centerline{$\land$}
\centerline{\emph{CMAC es computacionalmente indistinguible de FCBC}}

\begin{itemize}
	\item Seguridad ECBC: Se define como una nocion basada en juego, mediante el juego de colision de nombre, en donde el adversario A se le provee una lista de mensajes a su eleccion, antes de que la fusion hash f sea seleccionada de H. Este gana si contiene dos mensajes distinto con la misma imagen de h. Se dice que una funcion hash f es resistente a colision si la probabilidad es baja. Formalizando, la resistencia a colision de CBC-MAC es una familia de funciones hash indexada por un block cypher key. This yields a concrete bound on the security of ECBC.
	\item Seguridad FCBC: La seguridad FCBC es esquivalente a ECBC, esto es gracias a que la composicion de dos permutaciones aleatorias independientes quedan independientes de una de las permutaciones 
	\item Seguridad XCBC: La prueba de XCBC es indistinguible de FCBC se basa en que un adversario con oraculo accede a dos permutaciones aleatorias independientes $x_1$ y $x_2$ no pueden ser distinguidas de los oraculos $\pi (\cdot)$ y $\pi (k \oplus \cdot)$ cuando $\pi$ es una permutacion aleatoria y k es elegida uniformly at
random and independently from $\pi$
	\item Seguridad CMAC: La idea de esta seguridad de prevenir que el adversario acceda directamente el bloquede de cifrado del oraculo anadiendo una variable aleatoria independiente.
\end{itemize}
El caso fue exitoso ya que probó que CMAC es computacionalmente es indistinguible de FCBC, asi también los lemas utilizado para la prueba.


\centerline{\emph{Cramer-Shoup Cryptosystem}}

Agregar o no las definiciones de TGR y CCA
Cramer-Shoup Cryptosystem es una encripcionde llave publica basada en la encrypcion ElGramal,este caso se hizo famoso ya que fue el primer encriptador asimétrico eficiente. La idea es probar que es seguro contra ataques "adaptive chosen-ciphertext"
Mediante la prueba de las definiciones de Target Collision-Resistance y CCA-advantange), se puede probar
\begin{theorem}{Seguridad de Cramer-Shoup}
Let A be an adversary against the IND-CCA security
of Cramer-Shoup limited to $q_D$ decryption queries. Then, there exists an algorithm B for solving the
DDH problem in G and an adversary C against the target collision-resistance of the hash function H
such that
\[Adv_{CCA}^A(q_D) \leq Adv_{DDH}^B + Adv_{TCR}^C + \frac{q_D^4}{q^4} + \frac{q_D + 2}{q}\]
\end{theorem}
La prueba fue exitosa para cualquier "decryption query" (bajo la condicion de u =! u')\cite{article3}


\section{Conclusión}


Easycrypt es un programa que para su objetivo es muy eficiente ya que las verficaciones que brinda son mucho mas sencillas. Las actualizaciones que esperan sumarle, agrandarian la calidad y "espectro" de las respuestas que brinda, como por ejemplo agregarle asistentes como COQ. En comparacion a los otros programas y con la gran necesidad de seguridad en estos dias, EasyCrypt es un excelente programa con mucho potencial de mejorar.

A nivel de usuario, lo unico positivo que tiene es que es sencillo instalarlo, porque la interfaz grafica propia de Easycrypt no es facil de usar ni intuitiva y Emacs tiene mas facilidades pero aun asi los archivos a analizar no son nada sencillo y la informacion no abunda en la parte practica.

\section{Cosas que ver/hacer}
Objetivo de la herrramienta muy liviano

Revisar ortografia

\section{References}

\begin{thebibliography}{1}
\bibitem{article1}
Gilles Barthe François Dupressoir,Benjamin Grégoire,César Kunz, Benedikt Schmidt and Pierre-Yves Strub : EasyCrypt: A Tutorial. 
\bibitem{article2}
EasyCrypt Reference Manual.
%\bibitem{article4}
%Guillermo Ramos Gutiérrez: Desarrollo de  funcionalidad para un% marco orientado sobre algoritmos criptográficos.%
\bibitem{article3}
Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, Santiago Zanella Béguelin: Computer-Aided Security Proofs
for the Working Cryptographer.
\bibitem{article4}
Guillermo Ramos Gutiérrez: Implementing a term rewriting
engine for the EasyCrypt framework.
\bibitem{article5}
Cécile Baritel-Ruet, François Dupressoir, Pierre-Alain Fouque, Benjamin Grégoire. Formal Security.
Proof of CMAC and Its Variants. CSF 2018 - 31st EEE Computer Security Foundations Symposium,
Jul 2018, Oxford, United Kingdom.
\bibitem{article6}
David A. Basin, Andreas Lochbihler, and S. Reza Sefidgar: CryptHOL: Game-based Proofs in
Higher-order Logic.
\bibitem{link1}
Descarga e instalación EasyCrypt https://github.com/EasyCrypt/easycrypt
\bibitem{link2}
Descarga e instalacion EMACS https://www.easycrypt.info/binaries/ 
\end{thebibliography}
\end{document}
