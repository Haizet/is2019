
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsmath,latexsym}
\urldef{\mailsa}\path|{astradalucasezequiel@gmail.com|
\urldef{\mailsb}\path|marianvanetta@hotmail.com}
|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Tool Analysis, EasyCrypt}

% a short form should be given in case it is too long for the running head
\titlerunning{Tool Analysis, EasyCrypt}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
\author{Astrada Lucas Ezequiel
\and Vanetta Mariano}
%
\authorrunning{Tool Analysis, EasyCrypt}
% (feature abused for this document to repeat the title also on left hand pages) Aca sirve par el encabezado de pagina

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
\institute{Universidad Nacional de Cordoba, Facultad de Matematica, Fisica, Astronomia y Computacion\\
\mailsa\\
\mailsb\\
\url{https://www.famaf.unc.edu.ar/}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

\toctitle{Tool Analysis}
\tocauthor{EasyCrypt}
\maketitle


\begin{abstract}
Aca deberiamos escribir el resumen que el profe quiere
\end{abstract}

\section{Introduccion}

\section{Objetivos de EasyCrypt}

\section{EasyCrypt del lado del Usuario}

\section{Aspectos tecnicos}
5A
\cite{article5}
EasyCrypt trabaja con enfoque basado en juego, cuyos principales actores son los ADVERSARIOS y los ORACULOS. Este contiene variables globales y una coleciones de procesos: Procesos definidos (Oraculos) y Procesos Abstractos (Adversarsios).

Este posee 4 bases:
Lenguaje Programacional:
El lenguaje utilizado es pWhile el cual es de tipado fuerte, imperativo probabilistico.:

C ::= skip					nop
	|V <- E					deterministic assignment
	|V ← DE					probabilistic assignment
	|if E then C else C		conditional
	|while E do C			loop
	|V ← P(E, . . . , E)	procedure call
	|C; C					sequence
Donde V = {variables identificadora}
	P = {nombres de procesos}
	E = {expresiones de prueba}


Semantica Denotacional:
Estos programas son interpretados como funciones, que se mapean en la memoria.

Logica Relacional:
Se utiliza el metodo probabilistico RELATIONAL HOARE LOGIC (pRHL):
|= c 1 ∼ c 2 : Ψ ⇒ Φ	donde c1,c2 son programas probabilisticos y los simbolos corresponden a la pre y post condicion.
Dentro de EasyCrypt la gramatica es la siguiente
$Ψ, Φ ::= e | ¬Φ | Ψ ∧ Φ | Ψ ∨ Φ | Ψ =⇒ Φ | ∀x. Φ | ∃x. Φ$
Donde la e corresponde a una expresion Booleana.

Razonamiento probabilistico:
Estos razonamientos se expresan en terminos de eventos probabilisticos y no como juicios de pRHL.

9a
\cite{article6}
Easycrypt utiliza sistemas de reduccion abstractos sobre todo con el calculo lambda, estos son:
	-Call-by-name: reduce la exprecion de mas afuera de la izquierda salvo que este en forma normal devil. No es estricta.
	-Call-by-value: reduce la expresion de mas adentro de la izquierda, salvo que este en forma normal devil. Es estricta.
	-Applicative order: reduce la expresion de mas adentro a la izquierda, salvo que este de forma noraml. Es estricta.



-no encuentro nada de estados, ni de abstraccion
-tipo de respuestas


\section{COMPARACION DE PROGRAMAS}
5A
\cite{article5}
CeriCrypt Vs EasyCrypt:
En la parte programacional, EasyCrypt no posee bucles ni procesos recursivos. En el caso de las evidencias generadas, EasyCrypt es parcial por no tener generadores de pruebas COQ (se esta buscando agregar esta feature). Este tambien genera pruebas en base a la probabilidad y no maquinas totalmente probadas.

\begin{table}
  \caption{Comparación de EasyCrypt con CertyCrypt}
  \label{tab:simple1}
  \centering
  \begin{tabular}{ |p{3.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 & \multicolumn{2}{|c|}{CertiCrypt} & \multicolumn{2}{|c|}{EasyCrypt} & \multicolumn{2}{|c|}{Extracted} \\\cline{2-7}

 &Lines&Time&Lines&Time&Lines&Time\\\cline{2-7}
 \hline
 ElGamal(IND-CPA) & 565 & 45s & 190 & 12s & 1130 & 23s\\
 Hashed ElGamal(IND-CPA) & 1255  & 1m 5s & 243  & 33s & 1772 & 41s\\
 Full-Domain Hash(EF-CMA) & 2035 & 5m 46s&  509 & 1m 26s & 2724 & 1m11s\\
 Cramer-Shoup(IND-CCA) & n/a & n/a & 1637 & 5m 12s & 5504 & 3m14s\\
 OAEP (IND-CPA) & 2451 & 3m24s & n/a & n/a & n/a & n/a\\
 OAEP (IND-CPA) & 11162 & 37m32s & n/a & n/a & n/a & n/a\\
 \hline
\end{tabular}
\end{table}

Hardware para esta prueba: 2.8GHz Intel Core 2 Duo processor con 4GB de RAM en Mac OS X 10.6.7

10A
\cite{article8}
CRYPTHOL
En la semantica, EasyCrypt soporta distribuciones de probabildad discretas, todas expresadas usando el lenguaje pWhile. Crypthol tiene el mismo dominio y el lenguaje es igual de expresivo gracias al operador de punto fijo.

CryptHol crea su dominio semantico atravez de los principios de HOL y tiene la un asistente de prueba (COQ o Isabelle) para corroborar las derivaciones de las reglas de prueba. En cambio easycrypt no posee ningun asistente para las pruebas, entonces hay que confiar que las implementaciones en ocaml y que los "resolvedores" externos SMT son correctas


\begin{table}
  \caption{Comparación de EasyCrypt con CryptHOL}
  \label{tab:simple1}
  \centering
  \begin{tabular}{ |p{4cm}|p{1.5cm}|p{1.5cm}|p{1.5cm}|  }
 \hline
 Cryptographic Algorithm & Security property & CryptHOL & EasyCrypt\\\cline{1-4}
 \hline
 RP-RF switching lemma &  & 120 & 448\\
 Elgamal & IND-CPA & 49  & 68\\
 Hashed Elgamal in the ROM & IND-CPA & 253 &  216\\
 \hline
\end{tabular}
\end{table}


NO se encontro el hardware utilizado para esta prueba




\section{Casos de estudios}
EasyCrypt es una herramienta muy potente para probar problemas de seguridad, por lo tanto los siguientes casos de estudio hace referencia mayoritariamente la criptografia.

IND-CPA  5A
\cite{article5}
Hashed ElGamal es una variante de encriptacion ElGamal, la cual puede ser reducida a lo siguiente (Computational Diffie-Hellman) : Es dificil computa $g^x*y$ dado $g^x$ y $g^y$ donde x e y son eventos aleatorios uniformes dentro de Zq.
Para esta prueba primero es necesario expresar los cinco ingredientes para el input de EasyCrypt:
-Tipo, constantes y declaracioenes del operador;
-Axiomas;
-Defiiciones del "Juego"
-Juicios en pRHL;
-"Claims" de la probabildad

EXPLICAMOS O NO:

Resultado: La reduccion de codigo es sustancial tanto que es 5 veces mas chica que la inicial.

Type, constant and operator declarations, which introduce the objects manipulated by the scheme.
In this case, they include a type for elements of the cyclic group G, constants representing the
length of messages k, the order of the group q and a generator g, and operators denoting the group
law and exponentiation, and exclusive or on bitstrings;
2. Axioms, which capture mathematical properties of these objects, and are used by automated tools
to check the validity of the proof sketch. We use axioms to state properties of the group law and
exponentiation, and the exclusive or operator;
3. Game definitions, where adversaries are specified as abstract procedures with access to oracles.
In all games in the figure the hash function H is modeled as a random oracle and the adversary
is represented as two procedures A 1 and A 2 that share state. The procedures representing the
adversary are given access to a wrapper H A for the hash oracle that just stores queries in a list
L A before forwarding them to H:
$ {0, 1} k ; L[x] ← h end if; return L[x]
/ dom(L) then h ←
H(x) def
= if x ∈
def
H A (x) = L A ← x :: L A ; m ← H(x); return m
4. Judgments in pRHL. The general form of judgments is |= G 1 ∼ G 2 : Ψ ⇒ Φ, where G 1 and G 2
are games, and the pre-condition Ψ and the post-condition Φ are relations on program memories
(memories map program variables to values). Pre- and post-conditions are first-order formulae
built from relational expressions, in which language expressions are tagged with h1i or h2i to
denote their interpretation in the first or second game. We often consider equivalence of memories
on a set of variables X; we use = X as a shorthand for the formula ∀x ∈ X. xh1i = xh2i;
5. Claims about probability, built from probability quantities (the probability of an event in a game),
arithmetic operators, and mathematical relations (e.g. =, <, ≤). The final statement that expresses
the overall security guarantee brought by the proof sketch is usually a claim that upper bounds
the probability of adversary success in an initial attack game in terms of the probabilities of one
or more adversaries breaking security assumptions. $

We briefly comment on the sequence of games in Figure 1. The first and last games encode the IND-
CPA and LCDH experiments, respectively. We obtain G 1 by inlining the key generation and encryption
procedures in the initial game and rearranging instructions so that random choices are made upfront.
We prove that games IND-CPA and G 1 yield identical distributions on the result of the game (denoted
by the keyword res). We deduce from this that the probability of the event b = b ′ is the same in both
games.
In game G 2 we substitute the value H(ŷ) used to compute the challenge ciphertext by a uniformly
chosen value. This only makes a difference if A 1 queries ŷ to H, and this happens with the same probability in either game. Thus, the difference in the probability of any event in these games is
bounded by the probability of ŷ ∈ L A in G 2 . This can be seen as a semantic variant of the Fundamental
Lemma of Game-Playing; the logic allows to dispense with the code instrumentation needed to apply
the syntactic counterpart of the lemma.
The transition from G 2 to G 3 uses a code transformation known as optimistic sampling: instead of
sampling h and defining a value γ as h ⊕ m b , we sample γ and define h = γ ⊕ m b ; we then remove the
definition of h as dead code. This transformation is proven admissible within the logic and removes
the dependency of the adversary’s output from the challenge bit b.
The final transition performs the reduction to LCDH by exhibiting an adversary B that uses A
as a sub-procedure and for which the semantics of games LCDH and G 3 coincide. Finally, from the
preceding claims, the advantage of A can be bounded by the probability of B in solving LCDH. The
resulting proof sketch is about 250 lines long, about 5 times shorter than the proof in CertiCrypt
reported in [4]—and arguably much simpler and close to a pen-and-paper proof.
-------------------------------------------------------------

Cramer-Shoup Cryptosystem 5A
\cite{article5}
Este caso se hizo famoso ya que fue el primer encriptador asimetrico eficiente. La idea es probar que es seguro contra ataques "adaptive chosen-ciphertext"
Mediante la prueba de las definiciones de "Target Collision-Resistance" y CCA-advantange), se puede probar el teorema de "Security of Cramer-Shoup".
La prueba fue exitosa para cualquier "decryption query" (bajo la condicion de u =! u')

--------------------------------------------------------------

CMAC 6A caso exitoso
\cite{article7}
s
CMAC fue propuesto por 
The CMAC standard, when initially proposed by
Iwata and Kurosawa as OMAC1, was equipped with a complex
game-based security proof. Following recent advances in formal
verification for game-based security proofs, we formalize a proof
of unforgeability for CMAC in EasyCrypt. A side effect of
this proof includes improvements and extensions to EasyCrypt’s
standard libraries. This formal proof obtains security bounds
very similar to Iwata and Kurosawa’s for CMAC, but also
proves secure a certain number of intermediate constructions of
independent interest, including ECBC, FCBC and XCBC. This
work represents one more step in the direction of obtaining a
reliable set of independently verifiable evidence for the security
of international cryptographic standards.





A more ambitious goal
would be to enhance EasyCrypt with a language for programming strategies, in
the way proof assistants such as Coq allow users to program their own tactics.

\section{References}

\begin{thebibliography}{4}
\bibitem{article5}
Gilles Barthe, Benjamin Grégoire, Sylvain Heraud, Santiago Zanella Béguelin: Computer-Aided Security Proofs
for the Working Cryptographer
\bibitem{article6}
Guillermo Ramos Gutiérrez: Implementing a term rewriting
engine for the EasyCrypt framework
\bibitem{article7}
Cécile Baritel-Ruet, François Dupressoir, Pierre-Alain Fouque, Benjamin Grégoire. Formal Security
Proof of CMAC and Its Variants. CSF 2018 - 31st EEE Computer Security Foundations Symposium,
Jul 2018, Oxford, United Kingdom.
\bibitem{article8}
David A. Basin, Andreas Lochbihler, and S. Reza Sefidgar: CryptHOL: Game-based Proofs in
Higher-order Logic

\end{thebibliography}
\end{document}
